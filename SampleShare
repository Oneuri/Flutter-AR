#####################################################################################################################

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Update the node's transform in real-time
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Apply the final transformation to the node
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
15:40

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName);

  /*
  * Uncomment the following command if you want to keep the transformations of the Flutter representations of the nodes up to date
  * (e.g. if you intend to share the nodes through the cloud)
  */
  pannedNode.transform = newTransform;
}

#####################################################################################################################
15:43
onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null;
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}

#####################################################################################################################
15:52 onPlaneOrPointTapped method

Future<void> onPlaneOrPointTapped(List<ARHitTestResult> hitTestResults) async {
  var singleHitTestResult = hitTestResults.firstWhere(
      (hitTestResult) => hitTestResult.type == ARHitTestResultType.plane);
  if (singleHitTestResult != null) {
    var newAnchor =
        ARPlaneAnchor(transformation: singleHitTestResult.worldTransform);
    bool? didAddAnchor = await this.arAnchorManager!.addAnchor(newAnchor);
    if (didAddAnchor!) {
      this.anchors.add(newAnchor);

      var newNode = ARNode(
        type: NodeType.localGLTF2,
        uri: "Models/Chicken_01/Chicken_01.gltf",
        scale: Vector3(0.2, 0.2, 0.2),
        position: Vector3(0.0, 0.0, 0.0),
        rotation: Vector4(1.0, 0.0, 0.0, 0.0),
        name: "ChickenNode", // Ensure the node has a unique name
      );

      bool? didAddNodeToAnchor =
          await this.arObjectManager!.addNode(newNode, planeAnchor: newAnchor);
      if (didAddNodeToAnchor!) {
        this.nodes.add(newNode); // Add the node to the list
      } else {
        this.arSessionManager!.onError!("Adding Node to Anchor failed");
      }
    } else {
      this.arSessionManager!.onError!("Adding Anchor failed");
    }
  }
}

#####################################################################################################################
15:59 fixed null error

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  // Find the node being panned
  final ARNode? pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Return null if the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } else {
    print("Panning failed: Node not found.");
  }
}
#####################################################################################################################
17:31
corerected onpanchanged and onpanended

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  // Find the node being panned
  ARNode? pannedNode;
  try {
    pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);
  } catch (e) {
    print("Node not found: $nodeName");
    return; // Exit the method if the node is not found
  }

  // Update the node's transform with the new transformation matrix
  pannedNode.transform = newTransform;

  // Optional: Log the new transformation matrix for debugging
  print("New transform for $nodeName: $newTransform");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  ARNode? pannedNode;
  try {
    pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);
  } catch (e) {
    print("Node not found: $nodeName");
    return; // Exit the method if the node is not found
  }

  // Update the node's transform with the new transformation matrix
  pannedNode.transform = newTransform;

  // Optional: Log the new transformation matrix for debugging
  print("New transform for $nodeName: $newTransform");
}

#####################################################################################################################
17:42

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Handle the case where the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}
#####################################################################################################################
17:46

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################
8/5/2025 8:57
A value of type 'dynamic Function(String, Matrix4)' can't be assigned to a variable of type 'NodePanChangeHandler?'.
Try changing the type of the variable, or casting the right-hand type to 'NodePanChangeHandler?'.


onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Handle the case where the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}
#####################################################################################################################
8th may 15:15 PM
onPanStarted(String nodeName) {
  print("Started panning node " + nodeName);
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

Future<void> onPlaneOrPointTapped(List<ARHitTestResult> hitTestResults) async {
  var singleHitTestResult = hitTestResults.firstWhere(
      (hitTestResult) => hitTestResult.type == ARHitTestResultType.plane);
  if (singleHitTestResult != null) {
    var newAnchor =
        ARPlaneAnchor(transformation: singleHitTestResult.worldTransform);
    bool? didAddAnchor = await this.arAnchorManager!.addAnchor(newAnchor);
    if (didAddAnchor!) {
      this.anchors.add(newAnchor);

      // Add a node to the anchor
      var newNode = ARNode(
        type: NodeType.localGLTF2,
        uri: "Models/Chicken_01/Chicken_01.gltf",
        scale: Vector3(0.2, 0.2, 0.2),
        position: Vector3(0.0, 0.0, 0.0),
        rotation: Vector4(1.0, 0.0, 0.0, 0.0),
        name: "ChickenNode", // Assign a unique name to the node
      );

      print("Trying to add node");
      bool? didAddNodeToAnchor =
          await this.arObjectManager!.addNode(newNode, planeAnchor: newAnchor);
      if (didAddNodeToAnchor!) {
        this.nodes.add(newNode);
      } else {
        this.arSessionManager!.onError!("Adding Node to Anchor failed");
      }
    } else {
      this.arSessionManager!.onError!("Adding Anchor failed");
    }
  }
}

#####################################################################################################################
8th may 15:48 PM

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // App the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################
8th may 16:39 PM

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
9/5/2025 12:20
onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
