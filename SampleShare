

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Update the node's transform in real-time
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Apply the final transformation to the node
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}


15:40

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName);

  /*
  * Uncomment the following command if you want to keep the transformations of the Flutter representations of the nodes up to date
  * (e.g. if you intend to share the nodes through the cloud)
  */
  pannedNode.transform = newTransform;
}

15:43
onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null;
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}
