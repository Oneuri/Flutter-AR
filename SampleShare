#####################################################################################################################11

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Update the node's transform in real-time
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName, orElse: () => null);

  if (pannedNode != null) {
    // Apply the final transformation to the node
    pannedNode.transform = newTransform;
    this.arObjectManager!.updateNode(pannedNode);
  } else {
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
15:40

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);
  final pannedNode =
      this.nodes.firstWhere((element) => element.name == nodeName);

  /*
  * Uncomment the following command if you want to keep the transformations of the Flutter representations of the nodes up to date
  * (e.g. if you intend to share the nodes through the cloud)
  */
  pannedNode.transform = newTransform;
}

#####################################################################################################################
15:43
onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null;
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}

#####################################################################################################################
15:52 onPlaneOrPointTapped method

Future<void> onPlaneOrPointTapped(List<ARHitTestResult> hitTestResults) async {
  var singleHitTestResult = hitTestResults.firstWhere(
      (hitTestResult) => hitTestResult.type == ARHitTestResultType.plane);
  if (singleHitTestResult != null) {
    var newAnchor =
        ARPlaneAnchor(transformation: singleHitTestResult.worldTransform);
    bool? didAddAnchor = await this.arAnchorManager!.addAnchor(newAnchor);
    if (didAddAnchor!) {
      this.anchors.add(newAnchor);

      var newNode = ARNode(
        type: NodeType.localGLTF2,
        uri: "Models/Chicken_01/Chicken_01.gltf",
        scale: Vector3(0.2, 0.2, 0.2),
        position: Vector3(0.0, 0.0, 0.0),
        rotation: Vector4(1.0, 0.0, 0.0, 0.0),
        name: "ChickenNode", // Ensure the node has a unique name
      );

      bool? didAddNodeToAnchor =
          await this.arObjectManager!.addNode(newNode, planeAnchor: newAnchor);
      if (didAddNodeToAnchor!) {
        this.nodes.add(newNode); // Add the node to the list
      } else {
        this.arSessionManager!.onError!("Adding Node to Anchor failed");
      }
    } else {
      this.arSessionManager!.onError!("Adding Anchor failed");
    }
  }
}

#####################################################################################################################
15:59 fixed null error

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  // Find the node being panned
  final ARNode? pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Return null if the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } else {
    print("Panning failed: Node not found.");
  }
}
#####################################################################################################################
17:31
corerected onpanchanged and onpanended

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  // Find the node being panned
  ARNode? pannedNode;
  try {
    pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);
  } catch (e) {
    print("Node not found: $nodeName");
    return; // Exit the method if the node is not found
  }

  // Update the node's transform with the new transformation matrix
  pannedNode.transform = newTransform;

  // Optional: Log the new transformation matrix for debugging
  print("New transform for $nodeName: $newTransform");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  ARNode? pannedNode;
  try {
    pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);
  } catch (e) {
    print("Node not found: $nodeName");
    return; // Exit the method if the node is not found
  }

  // Update the node's transform with the new transformation matrix
  pannedNode.transform = newTransform;

  // Optional: Log the new transformation matrix for debugging
  print("New transform for $nodeName: $newTransform");
}

#####################################################################################################################
17:42

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Handle the case where the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}
#####################################################################################################################
17:46

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################
8/5/2025 8:57
A value of type 'dynamic Function(String, Matrix4)' can't be assigned to a variable of type 'NodePanChangeHandler?'.
Try changing the type of the variable, or casting the right-hand type to 'NodePanChangeHandler?'.


onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  // Find the node being panned
  final pannedNode = this.nodes.firstWhere(
    (element) => element.name == nodeName,
    orElse: () {
      print("Node not found: $nodeName");
      return null; // Handle the case where the node is not found
    },
  );

  if (pannedNode != null) {
    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }
}
#####################################################################################################################
8th may 15:15 PM
onPanStarted(String nodeName) {
  print("Started panning node " + nodeName);
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node " + nodeName);

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

Future<void> onPlaneOrPointTapped(List<ARHitTestResult> hitTestResults) async {
  var singleHitTestResult = hitTestResults.firstWhere(
      (hitTestResult) => hitTestResult.type == ARHitTestResultType.plane);
  if (singleHitTestResult != null) {
    var newAnchor =
        ARPlaneAnchor(transformation: singleHitTestResult.worldTransform);
    bool? didAddAnchor = await this.arAnchorManager!.addAnchor(newAnchor);
    if (didAddAnchor!) {
      this.anchors.add(newAnchor);

      // Add a node to the anchor
      var newNode = ARNode(
        type: NodeType.localGLTF2,
        uri: "Models/Chicken_01/Chicken_01.gltf",
        scale: Vector3(0.2, 0.2, 0.2),
        position: Vector3(0.0, 0.0, 0.0),
        rotation: Vector4(1.0, 0.0, 0.0, 0.0),
        name: "ChickenNode", // Assign a unique name to the node
      );

      print("Trying to add node");
      bool? didAddNodeToAnchor =
          await this.arObjectManager!.addNode(newNode, planeAnchor: newAnchor);
      if (didAddNodeToAnchor!) {
        this.nodes.add(newNode);
      } else {
        this.arSessionManager!.onError!("Adding Node to Anchor failed");
      }
    } else {
      this.arSessionManager!.onError!("Adding Anchor failed");
    }
  }
}

#####################################################################################################################
8th may 15:48 PM

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // App the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################
8th may 16:39 PM

onPanStarted(String nodeName) {
  print("Started panning node: $nodeName");
}

onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = this.nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
9/5/2025 12:20
onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################
9/5/2025 12:52

this.arObjectManager!.onPanChange = onPanChanged as void Function(String, Matrix4)?;
this.arObjectManager!.onPanEnd = onPanEnded as void Function(String, Matrix4)?;

void onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

void onPanEnded(String nodeName, Matrix4 newTransform) {
  print("Ended panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final transformation to the node
    pannedNode.transform = newTransform;

    // Optional: Log the final transformation matrix for debugging
    print("Final transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}
#####################################################################################################################

_TypeError (type '(String, Matrix4) => void' is not a subtype of type '((String) => void)?' in type cast)

this.arObjectManager!.onPanChange = (String nodeName) {
  onPanChanged(nodeName, Matrix4.identity());
};
void onARViewCreated(
  ARSessionManager arSessionManager,
  ARObjectManager arObjectManager,
  ARAnchorManager arAnchorManager,
  ARLocationManager arLocationManager,
) {
  this.arSessionManager = arSessionManager;
  this.arObjectManager = arObjectManager;
  this.arAnchorManager = arAnchorManager;

  this.arSessionManager!.onInitialize(
    showFeaturePoints: false,
    showPlanes: true,
    customPlaneTexturePath: "Images/triangle.png",
    showWorldOrigin: true,
    handlePans: true,
    handleRotation: true,
  );
  this.arObjectManager!.onInitialize();

  this.arSessionManager!.onPlaneOrPointTap = onPlaneOrPointTapped;
  this.arObjectManager!.onPanStart = onPanStarted;
  this.arObjectManager!.onPanChange = (String nodeName) {
    onPanChanged(nodeName, Matrix4.identity());
  };
  this.arObjectManager!.onPanEnd = (String nodeName) {
    onPanEnded(nodeName, Matrix4.identity());
  };
  this.arObjectManager!.onRotationStart = onRotationStarted;
  this.arObjectManager!.onRotationChange = onRotationChanged;
  this.arObjectManager!.onRotationEnd = onRotationEnded;
}

void onPanChanged(String nodeName, Matrix4 newTransform) {
  print("Continued panning node: $nodeName");

  try {
    // Find the node being panned
    final pannedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    pannedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
12/5/25 Monday
void onARViewCreated(
  ARSessionManager arSessionManager,
  ARObjectManager arObjectManager,
  ARAnchorManager arAnchorManager,
  ARLocationManager arLocationManager,
) {
  this.arSessionManager = arSessionManager;
  this.arObjectManager = arObjectManager;
  this.arAnchorManager = arAnchorManager;

  this.arSessionManager!.onInitialize(
    showFeaturePoints: false,
    showPlanes: true,
    customPlaneTexturePath: "Images/triangle.png",
    showWorldOrigin: true,
    handlePans: true,
    handleRotation: true,
    handleScales: true, // Enable scale gestures
  );
  this.arObjectManager!.onInitialize();

  this.arSessionManager!.onPlaneOrPointTap = onPlaneOrPointTapped;
  this.arObjectManager!.onPanStart = onPanStarted;
  this.arObjectManager!.onPanChange = onPanChanged;
  this.arObjectManager!.onPanEnd = onPanEnded;
  this.arObjectManager!.onRotationStart = onRotationStarted;
  this.arObjectManager!.onRotationChange = onRotationChanged;
  this.arObjectManager!.onRotationEnd = onRotationEnded;

  // Assign scale gesture handlers
  this.arObjectManager!.onScaleStart = onScaleStarted;
  this.arObjectManager!.onScaleChange = onScaleChanged;
  this.arObjectManager!.onScaleEnd = onScaleEnded;
}

void onScaleStarted(String nodeName) {
  print("Started scaling node: $nodeName");
}

void onScaleChanged(String nodeName, double scaleFactor) {
  print("Scaling node: $nodeName with scale factor: $scaleFactor");

  try {
    // Find the node being scaled
    final scaledNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's scale
    scaledNode.scale = Vector3.all(scaleFactor);

    // Optional: Log the new scale for debugging
    print("New scale for $nodeName: ${scaledNode.scale}");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

void onScaleEnded(String nodeName, double scaleFactor) {
  print("Ended scaling node: $nodeName");

  try {
    // Find the node being scaled
    final scaledNode = nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final scale to the node
    scaledNode.scale = Vector3.all(scaleFactor);

    // Optional: Log the final scale for debugging
    print("Final scale for $nodeName: ${scaledNode.scale}");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

#####################################################################################################################
Rotate guesture 
void onRotationStarted(String nodeName) {
  print("Started rotating node: $nodeName");
}

void onRotationChanged(String nodeName, double rotationAngle) {
  print("Rotating node: $nodeName with angle: $rotationAngle");

  try {
    // Find the node being rotated
    final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's rotation
    rotatedNode.rotation = Vector4(0.0, 1.0, 0.0, rotationAngle);

    // Optional: Log the new rotation for debugging
    print("New rotation for $nodeName: ${rotatedNode.rotation}");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

void onRotationEnded(String nodeName, double rotationAngle) {
  print("Ended rotating node: $nodeName");

  try {
    // Find the node being rotated
    final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Apply the final rotation to the node
    rotatedNode.rotation = Vector4(0.0, 1.0, 0.0, rotationAngle);

    // Optional: Log the final rotation for debugging
    print("Final rotation for $nodeName: ${rotatedNode.rotation}");
  } catch (e) {
    // Handle the case where the node is not found
    print("Node not found: $nodeName");
  }
}

void onARViewCreated(
  ARSessionManager arSessionManager,
  ARObjectManager arObjectManager,
  ARAnchorManager arAnchorManager,
  ARLocationManager arLocationManager,
) {
  this.arSessionManager = arSessionManager;
  this.arObjectManager = arObjectManager;
  this.arAnchorManager = arAnchorManager;

  this.arSessionManager!.onInitialize(
    showFeaturePoints: false,
    showPlanes: true,
    customPlaneTexturePath: "Images/triangle.png",
    showWorldOrigin: true,
    handlePans: true,
    handleRotation: true, // Enable rotation gestures
  );
  this.arObjectManager!.onInitialize();

  this.arSessionManager!.onPlaneOrPointTap = onPlaneOrPointTapped;
  this.arObjectManager!.onPanStart = onPanStarted;
  this.arObjectManager!.onPanChange = onPanChanged;
  this.arObjectManager!.onPanEnd = onPanEnded;
  this.arObjectManager!.onRotationStart = onRotationStarted;
  this.arObjectManager!.onRotationChange = onRotationChanged;
  this.arObjectManager!.onRotationEnd = onRotationEnded;
}
#####################################################################################################################
// ...existing code...

  void onRotationChanged(String nodeName, Matrix4 newTransform) {
    print("Continued rotating node: $nodeName");

    try {
      final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);
      rotatedNode.transform = newTransform;
      print("Live transform for $nodeName: $newTransform");
    } catch (e) {
      print("Node not found: $nodeName");
    }
  }

// ...existing code...

  onRotationEnded(String nodeName, Matrix4 newTransform) {
    print("Ended rotating node $nodeName");
    final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Update the node's transform with the new transformation matrix
    rotatedNode.transform = newTransform;

    // Optional: Log the new transformation matrix for debugging
    print("New transform for $nodeName: $newTransform");
  }

// ...existing code...
#####################################################################################################################

// ...existing code...

  onRotationEnded(String nodeName, Matrix4 newTransform) {
    print("Ended rotating node $nodeName");
    final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Get the current position of the node
    final Vector3 currentPosition = rotatedNode.position ?? Vector3.zero();

    // Step 1: Translate to origin
    Matrix4 toOrigin = Matrix4.translation(-currentPosition);

    // Step 2: Apply rotation (newTransform contains the rotation)
    Matrix4 rotation = Matrix4.identity();
    rotation.setFrom(newTransform);

    // Step 3: Translate back to original position
    Matrix4 backToPosition = Matrix4.translation(currentPosition);

    // Combine the transforms: T_back * R * T_origin * original
    Matrix4 finalTransform = backToPosition * rotation * toOrigin * rotatedNode.transform;

    // Update the node's transform
    rotatedNode.transform = finalTransform;

    print("Applied centered rotation for $nodeName: $finalTransform");
  }

// ...existing code...
#####################################################################################################################
// 

  onRotationEnded(String nodeName, Matrix4 newTransform) {
    print("Ended rotating node $nodeName");
    final rotatedNode = nodes.firstWhere((element) => element.name == nodeName);

    // Get the current position of the node (from its transform or position property)
    Vector3 position = rotatedNode.position ?? Vector3.zero();

    // Step 1: Translate to origin
    Matrix4 toOrigin = Matrix4.translation(-position);

    // Step 2: Apply the new rotation (assuming newTransform is a pure rotation matrix)
    Matrix4 rotation = Matrix4.identity();
    rotation.setFrom(newTransform);

    // Step 3: Translate back to original position
    Matrix4 backToPosition = Matrix4.translation(position);

    // Combine: T_back * R * T_origin * original
    Matrix4 finalTransform = backToPosition * rotation * toOrigin * rotatedNode.transform;

    rotatedNode.transform = finalTransform;

    print("Applied centered rotation for $nodeName: $finalTransform");
  }

// ...existing code...
#####################################################################################################################
